# Наследование `Python` класса

Чтобы сделать `PHP` класс наследником `Python` класса, используйте следующий метод.

## Установка Composer-пункта

Для этой функции необходимо дополнительно установить composer-расширение для `phpy` - `swoole/phpy`.

```shell
composer require swoole/phpy
```

## Писать PHP класс
```php
use phpy\PyClass;

#[Inherit('Animal', 'animal')]
class Dog extends PyClass
{
    protected string $weight;

    function __construct(string $name, int $age)
    {
        parent::__construct();
        // Этот атрибут не определен на уровне PHP и будет установлен как Python атрибут
        $this->color = 'black';
        // Этот атрибут определен на уровне PHP и не будет установлен как Python атрибут
        $this->weight = '10kg';
        // Чтение и запись Python атрибутов
        $this->self()->color = 'black';
        // вызов Python метода
        $this->get_age();
        $this->self()->get_age();
        // вызов конструктора родительского класса
        $this->super()->__init__($name, $age);
    }

    public function speak(string $name): void
    {
        echo "Dog $name, цвет: {$this->self()->color}, говорит: wang wang wang\n";
        $this->super()->speak('dog');
    }
    
    protected function test()
    {
        debug_print_backtrace();
    }
    
    // Этот метод не будет映射ен на уровень Python и не может быть использован в Python
    private function get_weight(): string
    {
        return $this->weight;
    }
}
```

- `PHP` класс должен наследоваться от базового класса `PyClass`
- Используйте атрибут `[Inherit('Animal', 'animal')]` для объявления отношений наследования
  - Первый параметр - имя `Python` класса, второй параметр - имя `Python` пакета

  - Поддерживается множественное наследование, можно добавить несколько атрибутов `[Inherit]` для объявления
- В конструкторе наследуемого класса необходимо сначала вызвать конструктор родительского класса `parent::__construct()`, иначе возникнет ошибка

## вызов конструктора базового класса
```php
$this->super()->__init__($name, $age);
```

Этот вызов должен быть произведен после `parent::__construct()`, иначе возникнет ошибка.

## Чтение и запись атрибутов
```php
$this->self()->color = 'black';
$this->color = 'red';
```

- Если у `PHP` класса и `Python` класса есть атрибуты с одинаковыми именами, можно использовать метод `$this->self()` для доступа к атрибутам `Python`
- Атрибуты, не определенные в `PHP` классе, могут быть accessed напрямую с помощью `$this->{$attr}`, что эквивалентно `$this->self()->{$attr}`

## вызов методов
```php
$this->self()->get_age();
$this->get_age();
```

- Если у `PHP` класса и `Python` родительского класса есть методы с одинаковыми именами, можно использовать метод `$this->self()->{$method}()` для вызова методов `Python`
- Методы, не определенные в `PHP` классе, могут быть вызваны напрямую с помощью `$this->{$method}()`, что эквивалентно `$this->self()->{$method}()`

## вызов методов родительского класса

Когда у наследуемого класса и родительского класса есть методы с одинаковыми именами, можно использовать метод `$this->super()->{$method}()` для вызова методов родительского класса.

```php
$this->super()->speak('dog');
```

## Множественное наследование

```php
#[Inherit('Animal', 'animal')]
#[Inherit('Base', 'dog')]
class Dog extends PyClass {}
```

Этот код эквивалентен следующему `Python` коду:
```python
class Dog(Animal, Base):
    pass
```

## Передача объекта в `Python` уровень
```php
$framework = PyCore::import('framework');
$framework->run($this->self());
```

В некоторых сценариях необходимо передать `PHP` объект в `Python` уровень, можно использовать метод `$this->self()` для получения объекта `Python` и передать его в `Python` уровень. Когда внутри `Python` необходимо вызвать метод объекта, будет вызван метод класса `PHP`.

> Только `public/protected` методы могут быть вызваны из `Python`

## Установка пути к прокси-файлам
```php
phpy\PyClass::setProxyDir(__DIR__, true);
```

- Первый параметр - путь к директории с прокси-файлами, в этой директории будет создана директория `__phpy_proxy__` и генерированы прокси-файлы, по умолчанию - путь к текущему рабочему каталогу
- Второй параметр - указывает, следует ли проверять, не устарели ли прокси-файлы. Когда время изменения прокси-файла меньше, чем время изменения файла класса `PHP`, прокси-файл будет пересоздан. По умолчанию - `false`
